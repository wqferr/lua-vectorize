# `vec` module functions

Functions marked with a `(I)` have an in-place variant. Check the
[section on in-place variants](#in-place-variants) for more information.

## Constructors

### `vec.new(size: number): vector`

Create a new vector with the given length.  
`size` must be a positive integer; all elements will be `0.0`.

This function can also be called as `vec(size)`.

<br/>

### `vec.ones(size: number): vector`

Create a new vector with the given length.  
`size` must be a positive integer; all elements will be `1.0`.

<br/>

### `vec.from(list: {number}): vector`

Create a new vector from the given elements.  
All elements of the given list must be numbers.

This function can also be called as `vec(list)`.

<br/>

### `vec.basis(size: number, b: number): vector`

Create a new vector where all elements are `0.0`, except for `v[b]`, which
will be `1.0`.  
`size` and `b` must be positive integers.

<br/>

### `vec.linspace(start: number, end: number, n: number): vector`

Create a new vector with length `n` whose elements are equally spaced between
`start` and `end` (inclusive).  
`n` must be a positive integer.

<br/>

### `vec.dup(original: vector): vector (I)`

Create a new vector with the same length and elements as `original`.

<br/>

---

## Serialization / deserialization

### `vec.save(v: vector, filename: string)`

Save the vector data to a file.  
The recommended extension for the file is `*.luavec`.

Please note that transferring a vector file from one machine to another is
not guaranteed to work. For more information, see `vec.load`.

<br/>

### `vec.load(filename: string): vector`

Load a vector from a file generated by `vec.save`.

Please note that transferring a vector file from one machine to another is
not guaranteed to work. If the machine architectures differ in the number
of bytes of `lua_Integer` or `lua_Number`, `vec.load` will detect this and
generate an error.

<br/>

---

## Misc.

### `vec.reset(v: vector)`

Set all elements in the vector to 0.

<br/>

---

## Arithmetic

### `vec.add(x, y): vector (I)`

This function is called automatically by `x + y`.

#### `x: vector, y: vector`

Element-wise addition of `x` and `y`. Errors if the two vectors don't have the
same length.

#### `x: vector, y: number`

Add `y` to every element of `x`.

#### `x: number, y: vector`

Add `x` to every element of `y`.

<br/>

### `vec.sub(x, y): vector (I)`

This function is called automatically by `x - y`.

#### `x: vector, y: vector`

Element-wise subtraction of `x` and `y`. Errors if the two vectors don't
have the same length.

#### `x: vector, y: number`

Subtract `y` from every element of `x`.

#### `x: number, y: vector`

Subtract every element of `y` from `x`.

<br/>

### `vec.mul(x, y): vector (I)`

This function is called automatically by `x * y`.

#### `x: vector, y: vector`

Element-wise multiplication of `x` and `y`. Equivalent to `vec.hadamard(x, y)`.
Errors if the two vectors don't have the same length.

#### `x: vector, y: number`

Equivalent to `vec.scale(x, y)`.

#### `x: number, y: vector`

Equivalent to `vec.scale(y, x)`.

<br/>

### `vec.div(x, y): vector (I)`

This function is called automatically by `x / y`.

#### `x: vector, y: vector`

Element-wise division of `x` and `y`. Roughly equivalent to
`x:hadamard(y:reciproc())`. Using this function instead of the previous snippet
will tend to yield slightly more precise results. Errors if the two vectors
don't have the same length.

#### `x: vector, y: number`

Divide every element of `x` by `y`. Roughly equivalent to `vec.scale(x, 1/y)`.
Using this function instead of the previous snippet will tend to yield slightly
more precise results.

#### `x: number, y: vector`

Divide `y` by every element of `x`. Roughly equivalent to
`vec.scale(y:reciproc(), x)`. Using this function instead of the previous
snippet will tend to yield slightly more precise results.

<br/>

### `vec.pow(x, y): vector (I)`

This function is called automatically by `x ^ y`.

#### `x: vector, y: vector`

Element-wise exponentiation of `x` and `y`. Errors if the two vectors don't
have the same length.

#### `x: vector, y: number`

Raise every element of `x` to the `y`-th power.

#### `x: number, y: vector`

Raise `x` to the power of each element of `y`.

<br/>

### `vec.neg(x: vector): vector (I)`

This function is called automatically by `-x`.

Element-wise negation of `x`. Optimized equivalent to `x:scale(-1)`.

<br/>

### `vec.reciproc(x: vector): vector (I)`

Element-wise reciprocal of `x`. More precise equivalent to `vec.div(1, x)`.

<br/>

### `vec.psy(x: vector, s: number, y: vector): vector (I)`

"Plus scaled y": adds `x` to `y` scaled by a factor of `s`. Roughly
equivalent to `x + s*y`. Using this function instead of the previous
snippet will tend to yield slightly more precise results at a slightly
better performance. Errors if the two vectors don't have the same length.

<br/>

### `vec.hadamard(x: vector, y: vector): vector (I)`

Element-wise product of `x` and `y`. Errors if the two vectors don't have
the same length.

<br/>

### `vec.scale(x: vector, s: number): vector (I)`

Element-wise multiplication of `x` by `s`.

<br/>

### `vec.inner(x: vector, y: vector): number`

Inner product between `x` and `y`. Also known as the scalar product or the dot
product between `x` and `y`. Errors if the two vectors don't have the same
length.

#### Aliases:

- `vec.dot`.

<br/>

### `vec.project(x: vector, y: vector): vector (I)`

Vector projection of `x` onto `y`. Errors if the two vectors don't have
the same length.

<br/>

### `vec.cosine_similarity(x: vector, y: vector): number`

Vector cosine similarity. Defined as
`(x:inner(y)) / (x:norm() * y:norm())`. Numerically equal to the cosine of
the angle between them, hence the name. Errors if the two vectors don't
have the same length. Using this function instead of the previous snippet
will tend to yield more precise results and have better performance.

<br/>

---

## Direct manipulation

### `vec.at(x: vector, i: number): number`

Access element of `x` at position `i`. Errors if `i < 1` or `i > #x`.

<br/>

### `vec.len(x: vector)`

Return the number of elements in `x`. This function is called automatically
by `#x`.

<br/>

### `vec.iter(x: vector): (function(): number, number)`

Iterate over all elements of `x`. Analogous to `ipairs` on a list-like
table.

<br/>

### `vec.sum(x: vector): number`

Sum all elements of the vector.

<br/>

---

## Norms and normalization

### `vec.norm(x: vector): number`

Euclidean norm of the vector.

<br/>

### `vec.norm2(x: vector): number`

Squared euclidean norm of the vector.

<br/>

### `vec.normalize(x: vector): vector (I)`

A vector with the same direction as `x`, but whose norm is `1.0`.

<br/>

---

## Numeric integration

See also: [`vec.ode` module](./ode.md).

### `vec.trapz(y: vector, x: vector): number`

Integrate using the trapezoid method for points with heights `y` and
abscissas `x`.

---

## Specialized algebra cases

### `vec.sq(x: vector): vector (I)`

Element-wise squaring of `x`. Tends to be faster and more precise than
`x:pow(2)`.  
Aliased to `vec.square`.

<br/>

### `vec.cb(x: vector): vector (I)`

Element-wise cubing of `x`. Tends to be faster and more precise than
`x:pow(3)`.  
Aliased to `vec.cube`.

<br/>

### `vec.sqrt(x: vector): vector (I)`

Element-wise square root of `x`.

<br/>

### `vec.cbrt(x: vector): vector (I)`

Element-wise cube root of `x`.

<br/>

---

## Exponentials and friends

### `vec.exp(x: vector): vector (I)`

Element-wise exponentiation (base `e`) of `x`.

<br/>

### `vec.expm1(x: vector): vector (I)`

Element-wise application of `exp(x)-1`. Roughly equivalent of `vec.exp(x)-1`.
Using this function instead of the previous snippet will tend to have better
performance and precision.

<br/>

### `vec.ln(x: vector): vector (I)`

Element-wise natural logarithm of `x`.

<br/>

### `vec.ln1p(x: vector): vector (I)`

Element-wise natural logarithm of `1+x`. Roughly equivalent to
`vec.ln(1+x)`. Using this function instead of the previous snippet will
tend to have better performance.

<br/>

---

## Trigonometry

### `vec.sin(x: vector): vector (I)`

Element-wise application of the `sin` trigonometric function.

<br/>

### `vec.asin(x: vector): vector (I)`

Element-wise application of the `asin` trigonometric function.

<br/>

### `vec.sinh(x: vector): vector (I)`

Element-wise application of the `sinh` hyperbolic trigonometric function.

<br/>

### `vec.asinh(x: vector): vector (I)`

Element-wise application of the `asinh` hyperbolic trigonometric function.

<br/>

### `vec.cos(x: vector): vector (I)`

Element-wise application of the `cos` trigonometric function.

<br/>

### `vec.acos(x: vector): vector (I)`

Element-wise application of the `acos` trigonometric function.

<br/>

### `vec.cosh(x: vector): vector (I)`

Element-wise application of the `cosh` hyperbolic trigonometric function.

<br/>

### `vec.acosh(x: vector): vector (I)`

Element-wise application of the `acosh` hyperbolic trigonometric function.

<br/>

### `vec.tan(x: vector): vector (I)`

Element-wise application of the `tan` trigonometric function.

<br/>

### `vec.atan(x: vector): vector (I)`

Element-wise application of the `atan` trigonometric function.

<br/>

### `vec.tanh(x: vector): vector (I)`

Element-wise application of the `tanh` hyperbolic trigonometric function.

<br/>

### `vec.atanh(x: vector): vector (I)`

Element-wise application of the `atanh` hyperbolic trigonometric function.

<br/>

---

## In-place variants

**In-place variants provide a way to minimize memory allocations for your
calculations. If this is not a concern for your use case, you may disregard
these notes.**

If a function has an in-place variant, you can request that it save the result
in an existing vector instead of creating and returning a new one.

This is done by appending a `_` to its name. For example:

```lua
local vec = require "vec"
local v = vec {0, math.pi/2, math.pi, 3/2 * math.pi, 2 * math.pi}
v:sin_() -- in-place operation: save result in self
print(v) -- [0.0, 1.0, 0.0, 1.0, 0.0]
```

The addition of the `_` makes a call to `sin` be an in-place operation. If,
instead, you wish to save the result into a different vector (but still one
that has been allocated already), that can also be done with in-place variants:

```lua
local vec = require "vec"
local v = vec {1, 2, 3, 4}
local w = vec {0, 0, 0, 0}

for _ = 1, 10 do
    vec.add_(v, w, w) -- or v:add_(w, w)
    --             ^ note the extra parameter
end
print(w) -- [10.0, 20.0, 30.0, 40.0]
```

The extra parameter to the `add_` function requests that the result be saved in
`w` instead of the first parameter.

In-place variants also return the vector they saved the result into, so their
integration with other coding practices (such as chaining calls) should be
identical to the use of their non-in-place variants.
